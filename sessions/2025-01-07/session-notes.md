# 学习笔记 - 2025-01-07

## 学习概述
- **日期**: 2025-01-07
- **时长**: 约 40 分钟
- **格式**: 复习测试 + 深入探讨
- **主要主题**: 复习测试、动态代理深入、反射原理、Spring IOC/DI、循环依赖

---

## 复习测试结果

### 测试题目与回答

| 题目 | 回答 | 结果 |
|------|------|------|
| 创建线程的方式和 Runnable vs Callable 区别 | 四种方式，返回值和异常区别 | ✅ 正确 |
| HashMap 底层数据结构 | 数组+链表+红黑树 | ✅ 正确 |
| 链表转红黑树条件 | 数组≥64，链表>8 | ✅ 正确 |
| MySQL 四个隔离级别 | 读未提交、读已提交、可重复读、序列化，默认可重复读 | ✅ 正确 |
| 缓存穿透/击穿/雪崩 | 查不存在数据、热key失效、多key同时失效 | ✅ 正确 |
| JDK代理 vs CGLIB | 接口 vs 类 | ✅ 正确 |

**复习测试评估**: 6/6 全对，之前学的知识掌握得很扎实！

---

## 深入学习内容

### 1. 动态代理详解

**学生初始理解**: 知道 JDK 代理基于接口，CGLIB 基于类，但不清楚代理模式的作用

**讲解内容**:

#### 代理模式的作用
- 在不修改原有代码的情况下，给方法增加额外功能
- 类比：中介（代理）帮你做额外的事，但核心事情还是房东（真实对象）完成

#### 静态代理 vs 动态代理
- 静态代理：手写代理类，100个Service要写100个代理类
- 动态代理：运行时自动生成代理类

#### JDK 动态代理原理
- 生成的代理类 `extends Proxy implements 接口`
- 因为 Java 单继承，已经继承 Proxy，只能通过接口建立关系
- 运行时每次方法调用都用反射 `Method.invoke()`

#### CGLIB 代理原理
- 用 ASM 库直接操作字节码，生成目标类的子类
- 不需要接口，直接继承目标类
- 运行时方法调用不用反射，用 FastClass 机制直接调用

**学生提出的好问题**:
1. "代理类里面一定有真实类或接口的注入是吧" → 理解正确
2. "JDK 代理的 Proxy 父类有什么用" → 持有 InvocationHandler
3. "CGLIB 为什么要用 ASM，不直接用反射增强" → 反射只能调用方法，不能修改方法
4. "我直接写子类覆盖不就行了" → 那是静态代理，动态代理的价值是运行时生成

**学生的理解总结**:
> "父类的作用是通过反射获取它的方法，ASM是那个工具，获取字节码然后动态生成新类，然后覆盖方法"

✅ 完全正确！

---

### 2. 反射原理

**学生问题**: "反射是为啥发明出来的，什么动机"

**讲解内容**:
- 动机：让程序在运行时"认识"自己不认识的类
- 场景：Spring 容器扫描 @Service 注解的类，自动创建对象
- 原理：JVM 加载类时创建 Class 对象，反射通过 Class 对象查询和操作类信息

**学生的关键问题**:
> "那我就算写了类名字符串，类我没写，不还是没办法运行吗"

**解答**: 字符串不是写死的，是运行时扫描文件系统动态获取的。Spring 扫描 .class 文件，得到类名字符串，用反射创建对象。

---

### 3. 依赖注入 vs 直接 new

**学生问题**: "我直接创建对象，有啥坏处"、"大多数接口只有一个实现类，注入和new有区别吗"

**讲解内容**:

#### 直接 new 的问题
1. 依赖写死，换实现要改代码
2. Spring 功能不生效（@Transactional、AOP）
3. 单元测试难写

#### 即使只有一个实现类
1. Spring 功能生效（代理对象 vs 裸对象）
2. 单例 vs 多例（注入是单例，new 每次创建新对象）

#### RestTemplate 应该注入
- 重量级对象，有连接池
- 需要统一配置（超时、拦截器）
- 方便测试

---

### 4. 一个接口多个实现的切换方式

**学生问题**: "如何修改配置可以直接切换实现"

**讲解内容**:
1. `@ConditionalOnProperty` + 配置文件（最推荐，只改配置不改代码）
2. `@Primary` + `@Qualifier`（学生指出这个还是要改代码）
3. `@Profile`（按环境切换）

---

### 5. Spring 容器和启动过程

**学生理解**: IOC、DI

**讲解内容**:

#### Spring 容器本质
- 就是一个 Map<String, Object>
- 对象工厂 + 对象仓库
- 学生比喻："小作坊和工厂的区别" ✅

#### 启动过程
1. 加载配置，扫描类
2. 创建 Bean 对象（IOC）
3. 依赖注入（DI）
4. 初始化

---

### 6. Bean 生命周期

**讲解内容**:
1. 实例化：new 对象
2. 属性注入：@Autowired 字段赋值
3. 初始化：@PostConstruct 执行
4. 使用
5. 销毁：@PreDestroy 执行

**学生问题**: "UserDao 是接口，为啥能成为属性"
**解答**: 注入的是实现类对象，多态：父类引用指向子类对象

---

### 7. 循环依赖（重点！）

**学生要求**: "非常非常详细的完整过程"

**讲解内容**:

#### 三级缓存定义
- 一级缓存：完整的 Bean
- 二级缓存：早期暴露的 Bean（已实例化，未注入属性）
- 三级缓存：Bean 工厂（用于生成早期对象或代理对象）

#### 完整流程（A 和 B 互相依赖）
1. 创建 A → 实例化 A → A 的工厂放入三级缓存
2. 注入 A 的属性 → 需要 B
3. 创建 B → 实例化 B → B 的工厂放入三级缓存
4. 注入 B 的属性 → 需要 A
5. 从三级缓存拿到 A 的工厂 → 调用工厂获取早期 A → 移到二级缓存
6. B 注入 A 成功 → B 完成 → B 放入一级缓存
7. 回到 A → A 注入 B 成功 → A 完成 → A 放入一级缓存

#### 为什么需要三级缓存
- 三级缓存存工厂，可以判断是否需要代理
- 如果 A 有 @Transactional，工厂返回代理对象
- 保证所有地方拿到的是同一个正确的对象

**学生的精彩理解**:
> "先过滤一下，给它定性，出去就不乱了"
> "A 不能自己给自己定性，得依赖第三方"
> "原始对象 = 素颜的人，代理对象 = 化完妆的人，工厂 = Tony + 化妆师"

✅ 理解非常到位！

---

## 识别的知识点

### 已掌握
- 动态代理原理（JDK vs CGLIB）- **高信心**
- 反射的作用和原理 - **高信心**
- Spring 容器概念 - **高信心**
- Bean 生命周期 - **高信心**
- 循环依赖三级缓存 - **高信心**
- 依赖注入的价值 - **高信心**

### 表现亮点
1. 复习测试 6/6 全对，之前的知识掌握扎实
2. 提问非常有深度，能抓住关键点
3. 善于用比喻理解复杂概念（Tony化妆师、小作坊vs工厂）
4. 能发现讲解中的不严谨之处（二级缓存的作用）

---

## 下次学习建议

1. 可以继续深入 Spring 相关主题：
   - 事务传播机制
   - AOP 五种通知类型
   - 自动配置原理

2. 或者回到高优先级薄弱点：
   - 服务雪崩处理
   - 消息幂等性
   - Redisson 看门狗机制
