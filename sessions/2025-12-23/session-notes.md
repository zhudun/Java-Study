# 学习笔记 - 2025-12-23

## 学习概述
- **日期**: 2025-12-23
- **时长**: 约 35 分钟
- **主要主题**: 多线程和并发测试、JVM 测试

---

## 第一部分：多线程和并发测试

### 问题 1: Runnable vs Callable
**学生回答**: 核心区别是一个没返回值，一个有返回值，需要回调查看线程使用情况的时候用 Callable

**评估**: ✅ 正确
- 准确理解了返回值的区别
- 补充：Callable 还能抛出受检异常

---

### 问题 2: 线程安全 - count++ 问题
**学生回答**: 不一定是 10000，因为并发会导致异常，总数会变少，解决方案是加锁或用原子类

**评估**: ✅ 正确
- 理解 count++ 不是原子操作
- 知道 synchronized 可以加在方法上或代码块
- 知道 Lock 锁的存在

---

### 问题 3: 死锁
**学生回答**: 两个串联锁，两个线程各拿一个，死锁了。避免方法：不搞串联锁

**评估**: ✅ 正确
- 准确描述了死锁场景
- 理解按固定顺序获取锁可避免死锁

---

### 问题 4: 线程池类型
**学生回答**: 
- newFixedThreadPool: 固定线程数量
- newCachedThreadPool: 增加缓存
- newSingleThreadExecutor: 单线程线程池

**评估**: ✅ 基本正确，细节需补充
- 理解基本特点
- 需补充：为什么阿里规范推荐 ThreadPoolExecutor

---

### 问题 5: ThreadPoolExecutor
**学生回答**: 更明确，可以控制参数

**评估**: ✅ 正确
- 理解 Executors 的问题（无界队列/无限线程可能 OOM）

---

### 问题 6: volatile
**学生回答**: 防重排，更原子化，底层的 CAS

**评估**: ⚠️ 概念混淆
- volatile 确实禁止重排序 ✅
- 但 volatile ≠ 原子性 ❌
- CAS 是 AtomicInteger 的底层，不是 volatile 的

---

## 识别的知识薄弱点

| 主题 | 严重程度 | 备注 |
|------|----------|------|
| volatile 可见性 vs 原子性 | 中 | 混淆了 volatile 和 CAS 的概念 |
| 线程池参数配置 | 低 | 知道概念但细节不熟 |

---

## 今日掌握的主题

| 主题 | 信心水平 | 备注 |
|------|----------|------|
| 线程创建方式 (Thread/Runnable/Callable/线程池) | 高 | 四种方式都清楚 |
| synchronized 和 Lock | 高 | 使用方式理解正确 |
| 线程安全概念 | 高 | 理解并发问题和解决方案 |
| 死锁原因和避免 | 高 | 场景描述准确 |
| 线程池基本类型 | 中高 | 基本特点清楚 |

---

## 涵盖的关键概念

- **Runnable vs Callable**: 返回值和异常处理的区别
- **count++ 线程安全**: 读-改-写不是原子操作
- **同步方案**: synchronized、Lock、AtomicInteger
- **死锁**: 互相等待对方持有的锁
- **线程池**: Fixed/Cached/Single 的区别
- **ThreadPoolExecutor**: 可控参数避免 OOM
- **volatile**: 可见性和禁止重排序（不保证原子性）

---

## 下次学习的行动项

- [ ] 复习: volatile 的可见性 vs synchronized 的互斥性
- [ ] 复习: CAS 原理和 AtomicInteger 的使用
- [ ] 练习: ThreadPoolExecutor 参数配置实战

---

## 备注
学生对多线程有较好的实战理解，概念基本正确。主要薄弱点是 volatile 和原子性的区分，建议通过代码示例加深理解。


---

## 第二部分：JVM 测试

### 问题 1: 内存区域
**学生回答**: a-方法区, b-栈, c-栈, obj-栈, new Object()-堆

**评估**: ⚠️ 部分正确
- 静态变量 a 存方法区 ✅
- 实例变量 b 存栈 ❌ (应该存堆，跟对象走)
- 局部变量 c 存栈 ✅
- 引用 obj 存栈 ✅
- new Object() 存堆 ✅

---

### 问题 2: 堆内存分代
**学生回答**: old, eden, survivor，青中老

**评估**: ✅ 正确
- 标准叫法掌握：Eden、Survivor、Old
- 对象流转过程理解正确

---

### 问题 3: GC 算法
**学生回答**: Parallel, G1

**评估**: ⚠️ 只答了收集器
- 没有区分 GC 算法（理论）和 GC 收集器（实现）
- 算法：标记-清除、标记-整理、复制算法
- 收集器：Parallel、CMS、G1、ZGC

---

### 问题 4: 类加载
**学生回答**: 不知道

**评估**: ❌ 需要学习
- 双亲委派机制不了解
- 类加载五个阶段不了解

---

### 问题 5: 问题排查
**学生回答**: 用 jstat

**评估**: ✅ 思路正确
- 知道用 jstat 查看 GC 情况
- 完整排查流程需要补充

---

## JVM 测试识别的知识薄弱点

| 主题 | 严重程度 | 备注 |
|------|----------|------|
| 类加载机制 | 高 | 双亲委派完全不了解 |
| 内存区域划分 | 中 | 实例变量位置搞混 |
| GC 算法 vs 收集器 | 中 | 概念混淆 |

---

## JVM 测试掌握的主题

| 主题 | 信心水平 | 备注 |
|------|----------|------|
| 堆内存分代 | 高 | Eden/Survivor/Old 清楚 |
| 问题排查工具 | 中高 | jstat 使用思路正确 |

---

## 下次学习的行动项

- [ ] 复习: 双亲委派机制
- [ ] 复习: JVM 内存区域（堆/栈/方法区各存什么）
- [ ] 复习: GC 算法（标记-清除、复制、标记-整理）
- [ ] 复习: volatile 可见性 vs 原子性


---

## 第三部分：MySQL 测试

### 问题 1: 联合索引
**学生回答**: C

**评估**: ❌ 漏答
- 正确答案：A、C、D 都能用索引
- A: name = '张三' ✅ 最左列
- B: age = 25 ❌ 跳过了 name
- C: name AND age ✅ 完全匹配
- D: age AND name ✅ 优化器会调整顺序

---

### 问题 2: ACID
**学生回答**: 持久性

**评估**: ✅ 正确
- 原子性、一致性、隔离性、持久性(Durability)

---

### 问题 3: 脏读/幻读/不可重复读
**学生回答**: 
- 脏读：看到未提交的数据 ✅
- 幻读：看到没有修改的数据 ❌
- 不可重复读：看到新增的数据 ❌

**评估**: ⚠️ 幻读和不可重复读搞反了
- 不可重复读：同一条数据两次读值不同（被修改）
- 幻读：同样条件两次读行数不同（被新增/删除）

---

### 问题 4: explain type
**学生回答**: all, index

**评估**: ⚠️ 不完整
- 完整排序：const > eq_ref > ref > range > index > ALL

---

### 问题 5: SQL 优化
**学生回答**: 通过 explain 看执行过程

**评估**: ⚠️ 太简略
- 需要更系统的排查思路

---

## MySQL 测试识别的知识薄弱点

| 主题 | 严重程度 | 备注 |
|------|----------|------|
| 幻读 vs 不可重复读 | 高 | 概念搞反 |
| 联合索引最左前缀 | 中 | 漏答 |
| explain type 字段 | 中 | 不完整 |
| SQL 优化思路 | 中 | 不够系统 |

---

## MySQL 测试掌握的主题

| 主题 | 信心水平 | 备注 |
|------|----------|------|
| 索引原理/B+树 | 高 | 理解正确 |
| ACID 特性 | 高 | 四个都知道 |
| 隔离级别 | 中高 | 四个级别都知道 |


---

## 第四部分：Spring Cloud 测试

### 问题 1: Nacos vs Eureka
**学生回答**: Nacos 可以单独拎出来，可以动态配置

**评估**: ⚠️ 部分正确
- 动态配置是对的
- 缺少：CP/AP 模式、健康检查方式、维护状态对比

---

### 问题 2: Feign
**学生回答**: 可以直接调同一注册中心的其他服务接口，不需要 IP 端口，底层不知道

**评估**: ⚠️ 使用理解对，原理不清楚
- 底层：动态代理 + 负载均衡 + HTTP 客户端

---

### 问题 3: Gateway
**学生回答**: 路由 ip 断言 服务名 过滤 多余的路径层级

**评估**: ⚠️ 理解模糊
- Route：路由规则，定义请求转发到哪个服务
- Predicate：断言/匹配条件
- Filter：过滤器，请求前后做处理

---

### 问题 4: 熔断降级限流
**学生回答**: 服务终止、服务优先级降低、限制访问

**评估**: ✅ 基本正确
- 熔断：下游故障时快速失败 ✅
- 降级：返回兜底数据（不是优先级降低）⚠️
- 限流：控制请求速率 ✅

---

### 问题 5: 服务雪崩
**学生回答**: 熔断（未展开）

**评估**: ❌ 太简略
- 完整方案：超时设置、熔断、线程隔离、降级

---

## Spring Cloud 测试识别的知识薄弱点

| 主题 | 严重程度 | 备注 |
|------|----------|------|
| 服务雪崩处理 | 高 | 没有完整回答 |
| Feign 底层原理 | 中 | 不清楚 |
| Gateway 核心概念 | 中 | 理解模糊 |
| 分布式事务 | 中 | 未接触 |

---

## Spring Cloud 测试掌握的主题

| 主题 | 信心水平 | 备注 |
|------|----------|------|
| Nacos 基本使用 | 高 | 注册发现+配置中心 |
| Feign 使用 | 高 | 声明式调用 |
| 熔断降级概念 | 中高 | 基本理解正确 |


---

## 第五部分：Redis 测试

### 问题 1: 数据结构
**学生回答**: sortedList、set（应该是 ZSet、Set）

**评估**: ✅ 基本正确
- 5 种都知道，名字说错了 sortedList → ZSet
- Hash vs String 存对象理解正确

---

### 问题 2: 持久化
**学生回答**: 一快一慢，一小一大，效率选 RDB，一致性选 AOF

**评估**: ✅ 正确
- RDB：快照，恢复快，可能丢数据
- AOF：日志，数据安全，恢复慢

---

### 问题 3: 缓存穿透/击穿/雪崩
**学生回答**: 
- 穿透：布隆过滤器 ✅
- 击穿：不过期 ✅
- 雪崩：分散过期 ✅

**评估**: ✅ 解决方案正确
- 之前概念搞混，已纠正

---

### 问题 4: 分布式锁
**学生回答**: 不知道 SETNX 用法，知道要设过期时间防止死锁，不知道看门狗

**评估**: ⚠️ 部分正确
- 知道过期时间的作用
- 不了解看门狗自动续期机制

---

### 问题 5: 缓存一致性
**学生回答**: 不知道

**评估**: ❌ 需要学习
- Cache Aside：先更新 DB，再删缓存
- 延迟双删
- 消息队列异步更新

---

## Redis 测试识别的知识薄弱点

| 主题 | 严重程度 | 备注 |
|------|----------|------|
| 缓存一致性 | 高 | 完全不了解 |
| 看门狗机制 | 中 | 不了解自动续期 |
| 集群模式 | 中 | 未考察 |

---

## Redis 测试掌握的主题

| 主题 | 信心水平 | 备注 |
|------|----------|------|
| 数据结构 | 高 | 5 种都知道 |
| 持久化 | 中高 | RDB/AOF 区别清楚 |
| 缓存三兄弟解决方案 | 中高 | 解决方案正确 |
| 分布式锁基础 | 中 | 知道基本概念 |


---

## 第六部分：Spring/Spring Boot 测试

### 问题 1: IOC 和 DI
**学生回答**: 一回事，忘了实现方式

**评估**: ⚠️ 理解不完整
- IOC 是思想，DI 是实现方式
- Spring 实现：扫描 → 解析 → 创建 → 注入

---

### 问题 2: AOP 通知类型
**学生回答**: 一前一后一环绕一异常，后者的结合

**评估**: ⚠️ 不完整
- 五种：Before/After/AfterReturning/AfterThrowing/Around
- 漏了 @AfterReturning

---

### 问题 3: Bean 生命周期
**学生回答**: 创建、初始化、干活、结束、销毁

**评估**: ✅ 基本正确
- @PostConstruct 在初始化阶段
- @PreDestroy 在销毁阶段

---

### 问题 4: 事务失效
**学生回答**: 会，a 里有 b

**评估**: ❌ 答反了
- 不会生效！内部调用不走代理
- 解决：拆分 Service 或注入自己

---

### 问题 5: 自动配置
**学生回答**: 三个忘了，配置文件

**评估**: ❌ 不清楚
- @SpringBootApplication = 三个注解
- 自动配置：spring.factories + @Conditional

---

## Spring/Spring Boot 测试识别的知识薄弱点

| 主题 | 严重程度 | 备注 |
|------|----------|------|
| 事务失效问题 | 高 | 内部调用不走代理 |
| 自动配置原理 | 高 | 完全不了解 |
| IOC/DI 原理 | 中 | 理解不完整 |
| AOP 通知类型 | 中 | 不完整 |

---

## Spring/Spring Boot 测试掌握的主题

| 主题 | 信心水平 | 备注 |
|------|----------|------|
| AOP 使用 | 中 | 实战用过 |
| Bean 生命周期 | 中高 | 流程清楚 |

---

## 今日测试总结

**测试模块**: 多线程、JVM、MySQL、Spring Cloud、Redis、Spring/Spring Boot
**总时长**: 约 105 分钟
**整体进度**: 19/89 主题 (21%)

**优势领域**:
- 实战使用能力强（各组件基本使用都会）
- 多线程掌握较好 (83%)

**薄弱领域**:
- 底层原理（Feign、看门狗、类加载、自动配置）
- 一致性问题（缓存一致性、分布式事务）
- 事务失效等坑点

**建议复习重点**:
1. Spring 事务失效（内部调用）
2. 缓存一致性方案
3. 类加载双亲委派
4. 幻读 vs 不可重复读


---

## 第七部分：消息队列测试

### 问题 1: MQ 作用
**学生回答**: 异步、削峰、解耦

**评估**: ✅ 正确
- 三大作用都答对了

---

### 问题 2: RabbitMQ 核心概念
**学生回答**: 生产者、消费者、队列、交换机、路由key，消息的集中分发

**评估**: ✅ 正确
- 五个核心概念都知道
- 理解消息流转过程

---

### 问题 3: 消息丢失
**学生回答**: 队列中，死信队列发送失败

**评估**: ⚠️ 不完整
- 三个环节：Producer→Broker、Broker存储、Broker→Consumer
- 解决方案：confirm、持久化、手动 ACK

---

### 问题 4: 幂等性
**学生回答**: kafka 幂等性，不知道

**评估**: ❌ 不了解
- 唯一 ID + 去重表
- 数据库唯一约束、Redis SETNX、状态机

---

### 问题 5: 实战设计
**学生回答**: 没有回答

**评估**: ❌ 需要学习
- 广播模式、独立消费、失败补偿

---

## 消息队列测试识别的知识薄弱点

| 主题 | 严重程度 | 备注 |
|------|----------|------|
| 幂等性保证 | 高 | 完全不了解 |
| 消息丢失处理 | 中 | 方案不完整 |
| 实战设计 | 中 | 没有回答 |

---

## 消息队列测试掌握的主题

| 主题 | 信心水平 | 备注 |
|------|----------|------|
| MQ 作用 | 高 | 三大作用都知道 |
| 核心概念 | 高 | 五个概念都清楚 |


---

## 第八部分：计算机网络测试

### 问题 1: HTTP vs HTTPS
**学生回答**: 端口 80 和 443，不安全 vs 安全

**评估**: ✅ 正确
- 端口和安全性都答对了

---

### 问题 2: TCP 三次握手
**学生回答**: 你好呀 → 你也好呀 → 好的我知道你好了

**评估**: ✅ 正确，比喻很棒！
- 理解三次握手的目的

---

### 问题 3: TCP 四次挥手
**学生回答**: 我要走了 → 你要走了吗 → 是的 → 好吧，三次不够

**评估**: ✅ 正确
- 理解为什么不能三次

---

### 问题 4: GET vs POST
**学生回答**: 不安全 vs 安全，参数小 vs 参数多

**评估**: ⚠️ 不完整
- 还有幂等性、缓存、语义等区别

---

### 问题 5: HTTP 状态码
**学生回答**: 正常，不知道

**评估**: ❌ 需要学习
- 需要记住常见状态码

---

## 计算机网络测试掌握的主题

| 主题 | 信心水平 | 备注 |
|------|----------|------|
| HTTP vs HTTPS | 高 | 端口和安全性清楚 |
| TCP 三次握手 | 高 | 比喻理解很好 |
| TCP 四次挥手 | 高 | 理解正确 |
| GET vs POST | 中 | 不完整 |
| HTTP 状态码 | 弱 | 需要学习 |


---

## 第九部分：设计模式测试

### 问题 1: 常用设计模式
**学生回答**: 单例、工厂、策略

**评估**: ✅ 正确
- 三个最常用的模式都知道

---

### 问题 2: 设计模式分类
**学生回答**: 创建型、结构型、行为型，用过一些

**评估**: ✅ 正确
- 三大分类都知道

---

### 问题 3: 单例模式写法
**学生回答**: 没写完，忘了。五种：懒汉式、双重锁、枚举、代码块

**评估**: ⚠️ 不完整
- 知道有多种方式
- 但写不出完整代码
- 漏了静态内部类方式

---

### 问题 4: 工厂模式三种区别
**学生回答**: 
- 简单工厂：生产简单的实例
- 工厂方法：生成简单的方法
- 抽象工厂：生产抽象方法

**评估**: ❌ 理解不准确
- 简单工厂：一个工厂类，根据参数创建不同对象
- 工厂方法：每种产品一个工厂类
- 抽象工厂：创建一系列相关产品（产品族）

---

### 问题 5: 策略模式
**学生回答**: 分流，消除 if-else

**评估**: ✅ 基本正确
- 理解策略模式的用途

---

### 问题 6: JDK 动态代理 vs CGLIB
**学生回答**: 
- 耦合性高 vs 动态无侵入
- 自带 vs 导包
- 接口 vs 类

**评估**: ⚠️ 部分正确
- 接口 vs 类的区别是对的
- 其他描述不够准确
- JDK：必须有接口，反射实现
- CGLIB：不需要接口，字节码生成（继承）

---

## 设计模式测试识别的知识薄弱点

| 主题 | 严重程度 | 备注 |
|------|----------|------|
| 单例模式写法 | 高 | 知道概念但写不出代码 |
| 工厂模式三种区别 | 高 | 理解不准确 |
| 代理模式原理 | 中 | 描述不够准确 |

---

## 设计模式测试掌握的主题

| 主题 | 信心水平 | 备注 |
|------|----------|------|
| 设计模式分类 | 高 | 三大分类清楚 |
| 策略模式用途 | 中高 | 理解消除 if-else |
| 代理模式使用 | 中 | 知道 JDK vs CGLIB 的选择 |

---

## 今日测试总结（更新）

**测试模块**: 多线程、JVM、MySQL、Spring Cloud、Redis、Spring/Spring Boot、消息队列、计算机网络、设计模式
**总时长**: 约 125 分钟
**整体进度**: 26/105 主题 (25%)

**优势领域**:
- 实战使用能力强（各组件基本使用都会）
- 多线程掌握较好 (83%)
- 计算机网络基础扎实 (60%)

**薄弱领域**:
- 底层原理（Feign、看门狗、类加载、自动配置）
- 一致性问题（缓存一致性、分布式事务）
- 事务失效等坑点
- 设计模式代码实现

**建议复习重点**:
1. Spring 事务失效（内部调用）
2. 缓存一致性方案
3. 类加载双亲委派
4. 幻读 vs 不可重复读
5. 单例模式五种写法
6. 工厂模式三种区别
